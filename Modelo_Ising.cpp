#include <iostream>
#include <cmath>
#include <fstream>
#include <string>

#include <random>
#include <time.h>

#define N 152


double EvaluarP(int n, int m, double s[N][N], double T ); //Si da error aqui, hay que quitar esos N's


using namespace std;
int main(void)
{
    int i,j,k,n,m,ciclo;
    double num,chi,p,s[N][N],T;
    double aleatorio;
    
    
    mt19937 semilla(time(NULL));
    uniform_real_distribution<double> numeroaleatorio_real(0.0,1.0);
    uniform_int_distribution<int> numeroaleatorio_entero(0,N-2);
    
    ofstream da,spin;

    da.open("datos_ising");
    
    spin.open("spin_negativo");

    //Para generar numeros aleatorios reales entre 0 y 1: x=gsl_rng_uniform(tau);
    
    //Para generar numeros aleatorios enteros entr 0 y N-1: i=gsl_rng_uniform_int(tau,N);

    //Inicialicemos la matriz s aleatoriamente
    
	
    for(i=1; i<N-2; i++)
    {
        for(j=1; j<N-2; j++)
        {
            aleatorio=numeroaleatorio_real(semilla);
            if(aleatorio<=0.5)
                s[i][j]=1.0;
            else
                s[i][j]=-1.0;
        }
    }
	
	for (j=1; j<=N-2; j++)
        {
          s[0][j]=s[N-2][j];
          s[N-1][j]=s[1][j];
          s[j][0]=s[j][N-2];
          s[j][N-1]=s[j][1];
        }
	
	
	
	//Inicializamos la temperatura recuerda que hay 20 ciclos porque tenemos que llegar a 5 kelvin en pasos de 0.25	
	T=0.1;
	
	for(ciclo=0;ciclo<20;ciclo++)
{
	//Número de pasos montecarlo que queremos realizar
	for(i=0;i<200;i++)
	{
	//Un paso montecarlo sería lo siguiente
	    for(k=0; k<(N*N); k++)
	    {
	        //Elegimos un elemento aleatorio de la matriz 
	
	        n=numeroaleatorio_entero(semilla);
	        m=numeroaleatorio_entero(semilla);
	        
	
	        //Evaluamos p=min(1,exp(-[E/T]))
	
	        p=EvaluarP(n,m,s,T);
	
	        //Generamos un número aleatorio uniforme entre 0 y 1, y provamos si es menor que p
	
	        chi=numeroaleatorio_real(semilla);
	        
	
	        if(chi<p)
	        {
	        	
	            s[n][m]=-s[n][m];
	        }
	
	        for (j=1; j<=N-2; j++)
	        {
	          s[0][j]=s[N-2][j];
	          s[N-1][j]=s[1][j];
	          s[j][0]=s[j][N-2];
	          s[j][N-1]=s[j][1];
	        }      
	
	    }
	}
    
    //###################################################################################################################
    	//Escribimos los resultado  
    for(i=1; i<N-2; i++)
    {
        for(j=1; j<N-2; j++)
        {	
        	if(j==N-3)
        	{
        		da<<s[i][j];	
			}
			else
			{
				da<<s[i][j]<<",";	
			}
            
            if(s[i][j]==-1)
            {
                spin<<i<<"\t"<<j<<endl;
			}
        }
        da<<endl;
    }
    da<<endl;
	
	T=T+0.25;   

}
    da.close();
    spin.close();
    

    return 0;
}

//########################################################################################################################################
//########################################################################################################################################
//########################################################################################################################################
//########################################################################################################################################
//########################################################################################################################################
//########################################################################################################################################
//########################################################################################################################################
//########################################################################################################################################
//########################################################################################################################################
//########################################################################################################################################
//########################################################################################################################################
//########################################################################################################################################
//########################################################################################################################################
//########################################################################################################################################
//########################################################################################################################################
//########################################################################################################################################
//########################################################################################################################################
//########################################################################################################################################

double EvaluarP(int n, int m, double s[N][N], double T)
{
    
    double p,E;
 
    
    E=2*s[n][m]*(s[n+1][m]+s[n-1][m]+s[n][m+1]+s[n][m-1]);
	p=min(1.0,exp(-E/T));


    return p;
}
